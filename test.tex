\documentclass{article}
\usepackage{fontspec}

\newfontfamily\englishtowne{EnglishTowne}[
  Path = fonts/,
  Extension = .ttf,
]

\begin{document}

This is a sample text in the default font.

{\englishtowne This is a sample text in the Englishtowne font.}


% \begin{algorithm}
% \caption{AES CBC Encrypt}
% \begin{algorithmic}
% \Function{AES\_CBC\_Encrypt}{$\text{plaintext}, \text{key}, \text{iv}$}
%   \State $ \text{// Divide plaintext into 128-bit blocks} $
%   \State $ \text{blocks} \gets \text{splitBlocks(plaintext, 128)} $
%   \State $ \text{previousCiphertext} \gets \text{iv} $
%   \State $ \text{// Generate round keys for AES} $
%   \State $ \text{roundKeys} \gets \text{getRoundKeys(key)} $
%   \newcounter{BlockIndex}
%   \setcounter{BlockIndex}{0}
%   \loop
%     \ifnum\value{BlockIndex}<\numexpr\lengthof{blocks}\relax
%       \State $ \text{// XOR plaintext block with previous ciphertext} $
%       \State $ \text{xoredBlock} \gets \text{xor(blocks[\arabic{BlockIndex}], previousCiphertext)} $
%       \State $ \text{// Encrypt xored block using AES} $
%       \State $ \text{encryptedBlock} \gets \text{AES\_Encrypt(xoredBlock, roundKeys)} $
%       \State $ \text{// Update previous ciphertext for next block} $
%       \State $ \text{previousCiphertext} \gets \text{encryptedBlock} $
%       \stepcounter{BlockIndex}
%   \repeat
%   \State $ \text{// Combine encrypted blocks as ciphertext} $
%   \State $ \text{ciphertext} \gets \text{combineBlocks(encryptedBlock)} $
%   \State \Return $\text{ciphertext}$
% \EndFunction
% \end{algorithmic}
% \end{algorithm}


% \begin{algorithm}
% \caption{AES CBC Decrypt}
% \begin{algorithmic}
% \Function{AES\_CBC\_Decrypt}{$\text{ciphertext}, \text{key}, \text{iv}$}
%   \State $ \text{// Split ciphertext into 128-bit blocks} $
%   \State $ \text{blocks} \gets \text{splitBlocks(ciphertext, 128)} $
%   \State $ \text{// Initialize previous ciphertext with IV} $
%   \State $ \text{previousCiphertext} \gets \text{iv} $
%   \State $ \text{// Loop through each ciphertext block} $
%   \State $ \text{decryptedBlocks} \gets [] $
%   \newcounter{BlockIndex}
%   \setcounter{BlockIndex}{0}
%   \loop
%     \ifnum\value{BlockIndex}<\numexpr\lengthof{blocks}\relax
%       \State $ \text{// Decrypt ciphertext block using AES} $
%       \State $ \text{decryptedBlock} \gets \text{AES\_Decrypt(blocks[\arabic{BlockIndex}], roundKeys)} $
%       \State $ \text{// XOR decrypted block with previous ciphertext} $
%       \State $ \text{xoredBlock} \gets \text{xor(decryptedBlock, previousCiphertext)} $
%       \State $ \text{// Update previous ciphertext for next block} $
%       \State $ \text{previousCiphertext} \gets \text{blocks[\arabic{BlockIndex}]} $
%       \State $ \text{// Append xored block to decrypted blocks} $
%       \State $ \text{append(decryptedBlocks, xoredBlock)} $
%       \stepcounter{BlockIndex}
%   \repeat
%   \State $ \text{// Combine decrypted blocks as plaintext} $
%   \State $ \text{plaintext} \gets \text{combineBlocks(decryptedBlocks)} $
%   \State \Return $\text{plaintext}$
% \EndFunction
% \end{algorithmic}
% \end{algorithm}


\end{document}
